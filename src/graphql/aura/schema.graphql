schema {
  query: Query
  subscription: Subscription
}

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

type Account {
  auraLockerAccount: AuraLockerAccount
  """
  Address
  
  """
  id: ID!
  merkleDropClaims(first: Int = 100, orderBy: MerkleDropClaim_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: MerkleDropClaim_filter): [MerkleDropClaim!]!
  poolAccounts(first: Int = 100, orderBy: PoolAccount_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PoolAccount_filter): [PoolAccount!]!
}

input Account_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  auraLockerAccount: String
  auraLockerAccount_contains: String
  auraLockerAccount_contains_nocase: String
  auraLockerAccount_ends_with: String
  auraLockerAccount_ends_with_nocase: String
  auraLockerAccount_gt: String
  auraLockerAccount_gte: String
  auraLockerAccount_in: [String!]
  auraLockerAccount_lt: String
  auraLockerAccount_lte: String
  auraLockerAccount_not: String
  auraLockerAccount_not_contains: String
  auraLockerAccount_not_contains_nocase: String
  auraLockerAccount_not_ends_with: String
  auraLockerAccount_not_ends_with_nocase: String
  auraLockerAccount_not_in: [String!]
  auraLockerAccount_not_starts_with: String
  auraLockerAccount_not_starts_with_nocase: String
  auraLockerAccount_starts_with: String
  auraLockerAccount_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
}

enum Account_orderBy {
  auraLockerAccount
  id
  merkleDropClaims
  poolAccounts
}

type AuraLocker {
  accounts(first: Int = 100, orderBy: AuraLockerAccount_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: AuraLockerAccount_filter): [AuraLockerAccount!]!
  address: Bytes!
  """
  Singleton: "AuraLocker"
  
  """
  id: ID!
  lockedSupply: BigInt!
  rewardData(first: Int = 100, orderBy: AuraLockerRewardData_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: AuraLockerRewardData_filter): [AuraLockerRewardData!]!
  totalSupply: BigInt!
}

type AuraLockerAccount {
  account: Account!
  auraLocker: AuraLocker!
  balance: BigInt!
  """
  AuraLocker.balances(account)
  
  """
  balanceLocked: BigInt!
  balanceNextUnlockIndex: Int!
  """
  {Account.id}
  
  """
  id: ID!
  """
  AuraLocker.userData(account)
  
  """
  userData(first: Int = 100, orderBy: AuraLockerUserData_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: AuraLockerUserData_filter): [AuraLockerUserData!]!
  """
  AuraLocker.userLocks(account)
  
  """
  userLocks(first: Int = 100, orderBy: AuraLockerUserLock_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: AuraLockerUserLock_filter): [AuraLockerUserLock!]!
}

input AuraLockerAccount_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  account: String
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  auraLocker: String
  auraLocker_contains: String
  auraLocker_contains_nocase: String
  auraLocker_ends_with: String
  auraLocker_ends_with_nocase: String
  auraLocker_gt: String
  auraLocker_gte: String
  auraLocker_in: [String!]
  auraLocker_lt: String
  auraLocker_lte: String
  auraLocker_not: String
  auraLocker_not_contains: String
  auraLocker_not_contains_nocase: String
  auraLocker_not_ends_with: String
  auraLocker_not_ends_with_nocase: String
  auraLocker_not_in: [String!]
  auraLocker_not_starts_with: String
  auraLocker_not_starts_with_nocase: String
  auraLocker_starts_with: String
  auraLocker_starts_with_nocase: String
  balance: BigInt
  balanceLocked: BigInt
  balanceLocked_gt: BigInt
  balanceLocked_gte: BigInt
  balanceLocked_in: [BigInt!]
  balanceLocked_lt: BigInt
  balanceLocked_lte: BigInt
  balanceLocked_not: BigInt
  balanceLocked_not_in: [BigInt!]
  balanceNextUnlockIndex: Int
  balanceNextUnlockIndex_gt: Int
  balanceNextUnlockIndex_gte: Int
  balanceNextUnlockIndex_in: [Int!]
  balanceNextUnlockIndex_lt: Int
  balanceNextUnlockIndex_lte: Int
  balanceNextUnlockIndex_not: Int
  balanceNextUnlockIndex_not_in: [Int!]
  balance_gt: BigInt
  balance_gte: BigInt
  balance_in: [BigInt!]
  balance_lt: BigInt
  balance_lte: BigInt
  balance_not: BigInt
  balance_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
}

enum AuraLockerAccount_orderBy {
  account
  auraLocker
  balance
  balanceLocked
  balanceNextUnlockIndex
  id
  userData
  userLocks
}

type AuraLockerRewardData implements RewardData {
  auraLocker: AuraLocker!
  """
  {token.id}
  
  """
  id: ID!
  lastUpdateTime: Int!
  periodFinish: Int!
  rewardPerTokenStored: BigInt!
  rewardRate: BigInt!
  token: Token!
}

input AuraLockerRewardData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  auraLocker: String
  auraLocker_contains: String
  auraLocker_contains_nocase: String
  auraLocker_ends_with: String
  auraLocker_ends_with_nocase: String
  auraLocker_gt: String
  auraLocker_gte: String
  auraLocker_in: [String!]
  auraLocker_lt: String
  auraLocker_lte: String
  auraLocker_not: String
  auraLocker_not_contains: String
  auraLocker_not_contains_nocase: String
  auraLocker_not_ends_with: String
  auraLocker_not_ends_with_nocase: String
  auraLocker_not_in: [String!]
  auraLocker_not_starts_with: String
  auraLocker_not_starts_with_nocase: String
  auraLocker_starts_with: String
  auraLocker_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastUpdateTime: Int
  lastUpdateTime_gt: Int
  lastUpdateTime_gte: Int
  lastUpdateTime_in: [Int!]
  lastUpdateTime_lt: Int
  lastUpdateTime_lte: Int
  lastUpdateTime_not: Int
  lastUpdateTime_not_in: [Int!]
  periodFinish: Int
  periodFinish_gt: Int
  periodFinish_gte: Int
  periodFinish_in: [Int!]
  periodFinish_lt: Int
  periodFinish_lte: Int
  periodFinish_not: Int
  periodFinish_not_in: [Int!]
  rewardPerTokenStored: BigInt
  rewardPerTokenStored_gt: BigInt
  rewardPerTokenStored_gte: BigInt
  rewardPerTokenStored_in: [BigInt!]
  rewardPerTokenStored_lt: BigInt
  rewardPerTokenStored_lte: BigInt
  rewardPerTokenStored_not: BigInt
  rewardPerTokenStored_not_in: [BigInt!]
  rewardRate: BigInt
  rewardRate_gt: BigInt
  rewardRate_gte: BigInt
  rewardRate_in: [BigInt!]
  rewardRate_lt: BigInt
  rewardRate_lte: BigInt
  rewardRate_not: BigInt
  rewardRate_not_in: [BigInt!]
  token: String
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
}

enum AuraLockerRewardData_orderBy {
  auraLocker
  id
  lastUpdateTime
  periodFinish
  rewardPerTokenStored
  rewardRate
  token
}

type AuraLockerUserData {
  auraLockerAccount: AuraLockerAccount!
  """
  {AuraLockerAccount.id}.{Token.id}
  
  """
  id: ID!
  rewardPerTokenPaid: BigInt!
  rewards: BigInt!
  token: Token!
}

input AuraLockerUserData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  auraLockerAccount: String
  auraLockerAccount_contains: String
  auraLockerAccount_contains_nocase: String
  auraLockerAccount_ends_with: String
  auraLockerAccount_ends_with_nocase: String
  auraLockerAccount_gt: String
  auraLockerAccount_gte: String
  auraLockerAccount_in: [String!]
  auraLockerAccount_lt: String
  auraLockerAccount_lte: String
  auraLockerAccount_not: String
  auraLockerAccount_not_contains: String
  auraLockerAccount_not_contains_nocase: String
  auraLockerAccount_not_ends_with: String
  auraLockerAccount_not_ends_with_nocase: String
  auraLockerAccount_not_in: [String!]
  auraLockerAccount_not_starts_with: String
  auraLockerAccount_not_starts_with_nocase: String
  auraLockerAccount_starts_with: String
  auraLockerAccount_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  rewardPerTokenPaid: BigInt
  rewardPerTokenPaid_gt: BigInt
  rewardPerTokenPaid_gte: BigInt
  rewardPerTokenPaid_in: [BigInt!]
  rewardPerTokenPaid_lt: BigInt
  rewardPerTokenPaid_lte: BigInt
  rewardPerTokenPaid_not: BigInt
  rewardPerTokenPaid_not_in: [BigInt!]
  rewards: BigInt
  rewards_gt: BigInt
  rewards_gte: BigInt
  rewards_in: [BigInt!]
  rewards_lt: BigInt
  rewards_lte: BigInt
  rewards_not: BigInt
  rewards_not_in: [BigInt!]
  token: String
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
}

enum AuraLockerUserData_orderBy {
  auraLockerAccount
  id
  rewardPerTokenPaid
  rewards
  token
}

type AuraLockerUserLock {
  amount: BigInt!
  auraLockerAccount: AuraLockerAccount!
  """
  {AuraLockerAccount.id}.{index}
  
  """
  id: ID!
  unlockTime: Int!
}

input AuraLockerUserLock_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  auraLockerAccount: String
  auraLockerAccount_contains: String
  auraLockerAccount_contains_nocase: String
  auraLockerAccount_ends_with: String
  auraLockerAccount_ends_with_nocase: String
  auraLockerAccount_gt: String
  auraLockerAccount_gte: String
  auraLockerAccount_in: [String!]
  auraLockerAccount_lt: String
  auraLockerAccount_lte: String
  auraLockerAccount_not: String
  auraLockerAccount_not_contains: String
  auraLockerAccount_not_contains_nocase: String
  auraLockerAccount_not_ends_with: String
  auraLockerAccount_not_ends_with_nocase: String
  auraLockerAccount_not_in: [String!]
  auraLockerAccount_not_starts_with: String
  auraLockerAccount_not_starts_with_nocase: String
  auraLockerAccount_starts_with: String
  auraLockerAccount_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  unlockTime: Int
  unlockTime_gt: Int
  unlockTime_gte: Int
  unlockTime_in: [Int!]
  unlockTime_lt: Int
  unlockTime_lte: Int
  unlockTime_not: Int
  unlockTime_not_in: [Int!]
}

enum AuraLockerUserLock_orderBy {
  amount
  auraLockerAccount
  id
  unlockTime
}

input AuraLocker_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  address: Bytes
  address_contains: Bytes
  address_in: [Bytes!]
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lockedSupply: BigInt
  lockedSupply_gt: BigInt
  lockedSupply_gte: BigInt
  lockedSupply_in: [BigInt!]
  lockedSupply_lt: BigInt
  lockedSupply_lte: BigInt
  lockedSupply_not: BigInt
  lockedSupply_not_in: [BigInt!]
  totalSupply: BigInt
  totalSupply_gt: BigInt
  totalSupply_gte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_lt: BigInt
  totalSupply_lte: BigInt
  totalSupply_not: BigInt
  totalSupply_not_in: [BigInt!]
}

enum AuraLocker_orderBy {
  accounts
  address
  id
  lockedSupply
  rewardData
  totalSupply
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type FactoryPoolData {
  gauge: Bytes!
  """
  {pool.id}
  
  """
  id: ID!
  isShutdown: Boolean!
  pool: Pool!
  stash: Bytes!
}

input FactoryPoolData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  gauge: Bytes
  gauge_contains: Bytes
  gauge_in: [Bytes!]
  gauge_not: Bytes
  gauge_not_contains: Bytes
  gauge_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isShutdown: Boolean
  isShutdown_in: [Boolean!]
  isShutdown_not: Boolean
  isShutdown_not_in: [Boolean!]
  pool: String
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  stash: Bytes
  stash_contains: Bytes
  stash_in: [Bytes!]
  stash_not: Bytes
  stash_not_contains: Bytes
  stash_not_in: [Bytes!]
}

enum FactoryPoolData_orderBy {
  gauge
  id
  isShutdown
  pool
  stash
}

type Global {
  aura: Bytes!
  auraMaxSupply: BigInt!
  auraMinter: Bytes!
  auraMinterMinted: BigInt!
  auraReductionPerCliff: BigInt!
  auraTotalCliffs: BigInt!
  auraTotalSupply: BigInt!
  """
  Singleton: "global"
  
  """
  id: ID!
}

input Global_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  aura: Bytes
  auraMaxSupply: BigInt
  auraMaxSupply_gt: BigInt
  auraMaxSupply_gte: BigInt
  auraMaxSupply_in: [BigInt!]
  auraMaxSupply_lt: BigInt
  auraMaxSupply_lte: BigInt
  auraMaxSupply_not: BigInt
  auraMaxSupply_not_in: [BigInt!]
  auraMinter: Bytes
  auraMinterMinted: BigInt
  auraMinterMinted_gt: BigInt
  auraMinterMinted_gte: BigInt
  auraMinterMinted_in: [BigInt!]
  auraMinterMinted_lt: BigInt
  auraMinterMinted_lte: BigInt
  auraMinterMinted_not: BigInt
  auraMinterMinted_not_in: [BigInt!]
  auraMinter_contains: Bytes
  auraMinter_in: [Bytes!]
  auraMinter_not: Bytes
  auraMinter_not_contains: Bytes
  auraMinter_not_in: [Bytes!]
  auraReductionPerCliff: BigInt
  auraReductionPerCliff_gt: BigInt
  auraReductionPerCliff_gte: BigInt
  auraReductionPerCliff_in: [BigInt!]
  auraReductionPerCliff_lt: BigInt
  auraReductionPerCliff_lte: BigInt
  auraReductionPerCliff_not: BigInt
  auraReductionPerCliff_not_in: [BigInt!]
  auraTotalCliffs: BigInt
  auraTotalCliffs_gt: BigInt
  auraTotalCliffs_gte: BigInt
  auraTotalCliffs_in: [BigInt!]
  auraTotalCliffs_lt: BigInt
  auraTotalCliffs_lte: BigInt
  auraTotalCliffs_not: BigInt
  auraTotalCliffs_not_in: [BigInt!]
  auraTotalSupply: BigInt
  auraTotalSupply_gt: BigInt
  auraTotalSupply_gte: BigInt
  auraTotalSupply_in: [BigInt!]
  auraTotalSupply_lt: BigInt
  auraTotalSupply_lte: BigInt
  auraTotalSupply_not: BigInt
  auraTotalSupply_not_in: [BigInt!]
  aura_contains: Bytes
  aura_in: [Bytes!]
  aura_not: Bytes
  aura_not_contains: Bytes
  aura_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
}

enum Global_orderBy {
  aura
  auraMaxSupply
  auraMinter
  auraMinterMinted
  auraReductionPerCliff
  auraTotalCliffs
  auraTotalSupply
  id
}

type MasterChef {
  endBlock: BigInt!
  """
  Address
  
  """
  id: ID!
  poolInfos(first: Int = 100, orderBy: MasterChefPoolInfo_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: MasterChefPoolInfo_filter): [MasterChefPoolInfo!]!
  rewardPerBlock: BigInt!
  startBlock: BigInt!
  totalAllocPoint: BigInt!
  userInfos(first: Int = 100, orderBy: MasterChefUserInfo_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: MasterChefUserInfo_filter): [MasterChefUserInfo!]!
}

type MasterChefPoolInfo {
  accCvxPerShare: BigInt!
  allocPoint: BigInt!
  """
  Pool ID (pid)
  
  """
  id: ID!
  lastRewardBlock: BigInt!
  lpSupply: BigInt!
  lpToken: Token!
  masterChef: MasterChef!
  rewarder: Bytes!
  userInfos(first: Int = 100, orderBy: MasterChefUserInfo_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: MasterChefUserInfo_filter): [MasterChefUserInfo!]!
}

input MasterChefPoolInfo_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  accCvxPerShare: BigInt
  accCvxPerShare_gt: BigInt
  accCvxPerShare_gte: BigInt
  accCvxPerShare_in: [BigInt!]
  accCvxPerShare_lt: BigInt
  accCvxPerShare_lte: BigInt
  accCvxPerShare_not: BigInt
  accCvxPerShare_not_in: [BigInt!]
  allocPoint: BigInt
  allocPoint_gt: BigInt
  allocPoint_gte: BigInt
  allocPoint_in: [BigInt!]
  allocPoint_lt: BigInt
  allocPoint_lte: BigInt
  allocPoint_not: BigInt
  allocPoint_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastRewardBlock: BigInt
  lastRewardBlock_gt: BigInt
  lastRewardBlock_gte: BigInt
  lastRewardBlock_in: [BigInt!]
  lastRewardBlock_lt: BigInt
  lastRewardBlock_lte: BigInt
  lastRewardBlock_not: BigInt
  lastRewardBlock_not_in: [BigInt!]
  lpSupply: BigInt
  lpSupply_gt: BigInt
  lpSupply_gte: BigInt
  lpSupply_in: [BigInt!]
  lpSupply_lt: BigInt
  lpSupply_lte: BigInt
  lpSupply_not: BigInt
  lpSupply_not_in: [BigInt!]
  lpToken: String
  lpToken_contains: String
  lpToken_contains_nocase: String
  lpToken_ends_with: String
  lpToken_ends_with_nocase: String
  lpToken_gt: String
  lpToken_gte: String
  lpToken_in: [String!]
  lpToken_lt: String
  lpToken_lte: String
  lpToken_not: String
  lpToken_not_contains: String
  lpToken_not_contains_nocase: String
  lpToken_not_ends_with: String
  lpToken_not_ends_with_nocase: String
  lpToken_not_in: [String!]
  lpToken_not_starts_with: String
  lpToken_not_starts_with_nocase: String
  lpToken_starts_with: String
  lpToken_starts_with_nocase: String
  masterChef: String
  masterChef_contains: String
  masterChef_contains_nocase: String
  masterChef_ends_with: String
  masterChef_ends_with_nocase: String
  masterChef_gt: String
  masterChef_gte: String
  masterChef_in: [String!]
  masterChef_lt: String
  masterChef_lte: String
  masterChef_not: String
  masterChef_not_contains: String
  masterChef_not_contains_nocase: String
  masterChef_not_ends_with: String
  masterChef_not_ends_with_nocase: String
  masterChef_not_in: [String!]
  masterChef_not_starts_with: String
  masterChef_not_starts_with_nocase: String
  masterChef_starts_with: String
  masterChef_starts_with_nocase: String
  rewarder: Bytes
  rewarder_contains: Bytes
  rewarder_in: [Bytes!]
  rewarder_not: Bytes
  rewarder_not_contains: Bytes
  rewarder_not_in: [Bytes!]
}

enum MasterChefPoolInfo_orderBy {
  accCvxPerShare
  allocPoint
  id
  lastRewardBlock
  lpSupply
  lpToken
  masterChef
  rewarder
  userInfos
}

type MasterChefUserInfo {
  account: Account!
  amount: BigInt!
  """
  ${poolInfo.id}.${account.id}
  
  """
  id: ID!
  masterChef: MasterChef!
  poolInfo: MasterChefPoolInfo!
  rewardDebt: BigInt!
}

input MasterChefUserInfo_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  account: String
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  masterChef: String
  masterChef_contains: String
  masterChef_contains_nocase: String
  masterChef_ends_with: String
  masterChef_ends_with_nocase: String
  masterChef_gt: String
  masterChef_gte: String
  masterChef_in: [String!]
  masterChef_lt: String
  masterChef_lte: String
  masterChef_not: String
  masterChef_not_contains: String
  masterChef_not_contains_nocase: String
  masterChef_not_ends_with: String
  masterChef_not_ends_with_nocase: String
  masterChef_not_in: [String!]
  masterChef_not_starts_with: String
  masterChef_not_starts_with_nocase: String
  masterChef_starts_with: String
  masterChef_starts_with_nocase: String
  poolInfo: String
  poolInfo_contains: String
  poolInfo_contains_nocase: String
  poolInfo_ends_with: String
  poolInfo_ends_with_nocase: String
  poolInfo_gt: String
  poolInfo_gte: String
  poolInfo_in: [String!]
  poolInfo_lt: String
  poolInfo_lte: String
  poolInfo_not: String
  poolInfo_not_contains: String
  poolInfo_not_contains_nocase: String
  poolInfo_not_ends_with: String
  poolInfo_not_ends_with_nocase: String
  poolInfo_not_in: [String!]
  poolInfo_not_starts_with: String
  poolInfo_not_starts_with_nocase: String
  poolInfo_starts_with: String
  poolInfo_starts_with_nocase: String
  rewardDebt: BigInt
  rewardDebt_gt: BigInt
  rewardDebt_gte: BigInt
  rewardDebt_in: [BigInt!]
  rewardDebt_lt: BigInt
  rewardDebt_lte: BigInt
  rewardDebt_not: BigInt
  rewardDebt_not_in: [BigInt!]
}

enum MasterChefUserInfo_orderBy {
  account
  amount
  id
  masterChef
  poolInfo
  rewardDebt
}

input MasterChef_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  endBlock: BigInt
  endBlock_gt: BigInt
  endBlock_gte: BigInt
  endBlock_in: [BigInt!]
  endBlock_lt: BigInt
  endBlock_lte: BigInt
  endBlock_not: BigInt
  endBlock_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  rewardPerBlock: BigInt
  rewardPerBlock_gt: BigInt
  rewardPerBlock_gte: BigInt
  rewardPerBlock_in: [BigInt!]
  rewardPerBlock_lt: BigInt
  rewardPerBlock_lte: BigInt
  rewardPerBlock_not: BigInt
  rewardPerBlock_not_in: [BigInt!]
  startBlock: BigInt
  startBlock_gt: BigInt
  startBlock_gte: BigInt
  startBlock_in: [BigInt!]
  startBlock_lt: BigInt
  startBlock_lte: BigInt
  startBlock_not: BigInt
  startBlock_not_in: [BigInt!]
  totalAllocPoint: BigInt
  totalAllocPoint_gt: BigInt
  totalAllocPoint_gte: BigInt
  totalAllocPoint_in: [BigInt!]
  totalAllocPoint_lt: BigInt
  totalAllocPoint_lte: BigInt
  totalAllocPoint_not: BigInt
  totalAllocPoint_not_in: [BigInt!]
}

enum MasterChef_orderBy {
  endBlock
  id
  poolInfos
  rewardPerBlock
  startBlock
  totalAllocPoint
  userInfos
}

type MerkleDrop {
  claims(first: Int = 100, orderBy: MerkleDropClaim_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: MerkleDropClaim_filter): [MerkleDropClaim!]!
  expiryTime: Int!
  """
  Address
  
  """
  id: ID!
  merkleRoot: Bytes!
  startTime: Int!
}

type MerkleDropClaim {
  account: Account!
  amount: BigInt!
  """
  {merkleDrop.id}.{account.id}
  
  """
  id: ID!
  locked: Boolean!
  merkleDrop: MerkleDrop!
}

input MerkleDropClaim_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  account: String
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  locked: Boolean
  locked_in: [Boolean!]
  locked_not: Boolean
  locked_not_in: [Boolean!]
  merkleDrop: String
  merkleDrop_contains: String
  merkleDrop_contains_nocase: String
  merkleDrop_ends_with: String
  merkleDrop_ends_with_nocase: String
  merkleDrop_gt: String
  merkleDrop_gte: String
  merkleDrop_in: [String!]
  merkleDrop_lt: String
  merkleDrop_lte: String
  merkleDrop_not: String
  merkleDrop_not_contains: String
  merkleDrop_not_contains_nocase: String
  merkleDrop_not_ends_with: String
  merkleDrop_not_ends_with_nocase: String
  merkleDrop_not_in: [String!]
  merkleDrop_not_starts_with: String
  merkleDrop_not_starts_with_nocase: String
  merkleDrop_starts_with: String
  merkleDrop_starts_with_nocase: String
}

enum MerkleDropClaim_orderBy {
  account
  amount
  id
  locked
  merkleDrop
}

input MerkleDrop_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  expiryTime: Int
  expiryTime_gt: Int
  expiryTime_gte: Int
  expiryTime_in: [Int!]
  expiryTime_lt: Int
  expiryTime_lte: Int
  expiryTime_not: Int
  expiryTime_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  merkleRoot: Bytes
  merkleRoot_contains: Bytes
  merkleRoot_in: [Bytes!]
  merkleRoot_not: Bytes
  merkleRoot_not_contains: Bytes
  merkleRoot_not_in: [Bytes!]
  startTime: Int
  startTime_gt: Int
  startTime_gte: Int
  startTime_in: [Int!]
  startTime_lt: Int
  startTime_lte: Int
  startTime_not: Int
  startTime_not_in: [Int!]
}

enum MerkleDrop_orderBy {
  claims
  expiryTime
  id
  merkleRoot
  startTime
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Pool {
  accounts(first: Int = 100, orderBy: PoolAccount_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PoolAccount_filter): [PoolAccount!]!
  """
  The Aura deposit token; a 1:1 token representing an LP deposit.
  - Factory pools    => an auraLP token
  - auraBAL staking  => auraBAL
  
  """
  depositToken: Token!
  factoryPoolData: FactoryPoolData
  """
  Pool ID (pid)
  
  """
  id: ID!
  isFactoryPool: Boolean!
  """
  LP Token refers to:
  - Factory pools    => e.g. a given BPT
  - auraBAL staking  => BAL
  
  """
  lpToken: Token!
  """
  List of rewards per-token
  
  """
  rewardData(first: Int = 100, orderBy: PoolRewardData_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PoolRewardData_filter): [PoolRewardData!]!
  """
  BaseRewardPool (for factory pools)
  
  """
  rewardPool: Bytes!
  """
  auraBal initial staking only
  
  """
  startTime: Int
  """
  Total staked in the rewardPool
  
  """
  totalStaked: BigInt!
  """
  Total supply of the depositToken
  
  """
  totalSupply: BigInt!
}

type PoolAccount {
  account: Account!
  """
  depositToken.balanceOf(account)
  
  """
  balance: BigInt!
  """
  {Pool.id}.{Account.id}
  
  """
  id: ID!
  pool: Pool!
  """
  userRewardPerTokenPaid(account)
  
  """
  rewardPerTokenPaid: BigInt!
  """
  rewards(account)
  
  """
  rewards: BigInt!
  """
  rewardsPool.balanceOf(account)
  i.e. the account's staked LP tokens
  
  """
  staked: BigInt!
}

input PoolAccount_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  account: String
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  balance: BigInt
  balance_gt: BigInt
  balance_gte: BigInt
  balance_in: [BigInt!]
  balance_lt: BigInt
  balance_lte: BigInt
  balance_not: BigInt
  balance_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pool: String
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  rewardPerTokenPaid: BigInt
  rewardPerTokenPaid_gt: BigInt
  rewardPerTokenPaid_gte: BigInt
  rewardPerTokenPaid_in: [BigInt!]
  rewardPerTokenPaid_lt: BigInt
  rewardPerTokenPaid_lte: BigInt
  rewardPerTokenPaid_not: BigInt
  rewardPerTokenPaid_not_in: [BigInt!]
  rewards: BigInt
  rewards_gt: BigInt
  rewards_gte: BigInt
  rewards_in: [BigInt!]
  rewards_lt: BigInt
  rewards_lte: BigInt
  rewards_not: BigInt
  rewards_not_in: [BigInt!]
  staked: BigInt
  staked_gt: BigInt
  staked_gte: BigInt
  staked_in: [BigInt!]
  staked_lt: BigInt
  staked_lte: BigInt
  staked_not: BigInt
  staked_not_in: [BigInt!]
}

enum PoolAccount_orderBy {
  account
  balance
  id
  pool
  rewardPerTokenPaid
  rewards
  staked
}

type PoolRewardData implements RewardData {
  """
  {pool.id}.{token.id}
  
  """
  id: ID!
  lastUpdateTime: Int!
  periodFinish: Int!
  pool: Pool!
  rewardPerTokenStored: BigInt!
  rewardRate: BigInt!
  token: Token!
}

input PoolRewardData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastUpdateTime: Int
  lastUpdateTime_gt: Int
  lastUpdateTime_gte: Int
  lastUpdateTime_in: [Int!]
  lastUpdateTime_lt: Int
  lastUpdateTime_lte: Int
  lastUpdateTime_not: Int
  lastUpdateTime_not_in: [Int!]
  periodFinish: Int
  periodFinish_gt: Int
  periodFinish_gte: Int
  periodFinish_in: [Int!]
  periodFinish_lt: Int
  periodFinish_lte: Int
  periodFinish_not: Int
  periodFinish_not_in: [Int!]
  pool: String
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  rewardPerTokenStored: BigInt
  rewardPerTokenStored_gt: BigInt
  rewardPerTokenStored_gte: BigInt
  rewardPerTokenStored_in: [BigInt!]
  rewardPerTokenStored_lt: BigInt
  rewardPerTokenStored_lte: BigInt
  rewardPerTokenStored_not: BigInt
  rewardPerTokenStored_not_in: [BigInt!]
  rewardRate: BigInt
  rewardRate_gt: BigInt
  rewardRate_gte: BigInt
  rewardRate_in: [BigInt!]
  rewardRate_lt: BigInt
  rewardRate_lte: BigInt
  rewardRate_not: BigInt
  rewardRate_not_in: [BigInt!]
  token: String
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
}

enum PoolRewardData_orderBy {
  id
  lastUpdateTime
  periodFinish
  pool
  rewardPerTokenStored
  rewardRate
  token
}

input Pool_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  depositToken: String
  depositToken_contains: String
  depositToken_contains_nocase: String
  depositToken_ends_with: String
  depositToken_ends_with_nocase: String
  depositToken_gt: String
  depositToken_gte: String
  depositToken_in: [String!]
  depositToken_lt: String
  depositToken_lte: String
  depositToken_not: String
  depositToken_not_contains: String
  depositToken_not_contains_nocase: String
  depositToken_not_ends_with: String
  depositToken_not_ends_with_nocase: String
  depositToken_not_in: [String!]
  depositToken_not_starts_with: String
  depositToken_not_starts_with_nocase: String
  depositToken_starts_with: String
  depositToken_starts_with_nocase: String
  factoryPoolData: String
  factoryPoolData_contains: String
  factoryPoolData_contains_nocase: String
  factoryPoolData_ends_with: String
  factoryPoolData_ends_with_nocase: String
  factoryPoolData_gt: String
  factoryPoolData_gte: String
  factoryPoolData_in: [String!]
  factoryPoolData_lt: String
  factoryPoolData_lte: String
  factoryPoolData_not: String
  factoryPoolData_not_contains: String
  factoryPoolData_not_contains_nocase: String
  factoryPoolData_not_ends_with: String
  factoryPoolData_not_ends_with_nocase: String
  factoryPoolData_not_in: [String!]
  factoryPoolData_not_starts_with: String
  factoryPoolData_not_starts_with_nocase: String
  factoryPoolData_starts_with: String
  factoryPoolData_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isFactoryPool: Boolean
  isFactoryPool_in: [Boolean!]
  isFactoryPool_not: Boolean
  isFactoryPool_not_in: [Boolean!]
  lpToken: String
  lpToken_contains: String
  lpToken_contains_nocase: String
  lpToken_ends_with: String
  lpToken_ends_with_nocase: String
  lpToken_gt: String
  lpToken_gte: String
  lpToken_in: [String!]
  lpToken_lt: String
  lpToken_lte: String
  lpToken_not: String
  lpToken_not_contains: String
  lpToken_not_contains_nocase: String
  lpToken_not_ends_with: String
  lpToken_not_ends_with_nocase: String
  lpToken_not_in: [String!]
  lpToken_not_starts_with: String
  lpToken_not_starts_with_nocase: String
  lpToken_starts_with: String
  lpToken_starts_with_nocase: String
  rewardPool: Bytes
  rewardPool_contains: Bytes
  rewardPool_in: [Bytes!]
  rewardPool_not: Bytes
  rewardPool_not_contains: Bytes
  rewardPool_not_in: [Bytes!]
  startTime: Int
  startTime_gt: Int
  startTime_gte: Int
  startTime_in: [Int!]
  startTime_lt: Int
  startTime_lte: Int
  startTime_not: Int
  startTime_not_in: [Int!]
  totalStaked: BigInt
  totalStaked_gt: BigInt
  totalStaked_gte: BigInt
  totalStaked_in: [BigInt!]
  totalStaked_lt: BigInt
  totalStaked_lte: BigInt
  totalStaked_not: BigInt
  totalStaked_not_in: [BigInt!]
  totalSupply: BigInt
  totalSupply_gt: BigInt
  totalSupply_gte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_lt: BigInt
  totalSupply_lte: BigInt
  totalSupply_not: BigInt
  totalSupply_not_in: [BigInt!]
}

enum Pool_orderBy {
  accounts
  depositToken
  factoryPoolData
  id
  isFactoryPool
  lpToken
  rewardData
  rewardPool
  startTime
  totalStaked
  totalSupply
}

type Query {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  account(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Account_filter
  ): [Account!]!
  auraLocker(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLocker
  auraLockerAccount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerAccount
  auraLockerAccounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLockerAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLockerAccount_filter
  ): [AuraLockerAccount!]!
  auraLockerRewardData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerRewardData
  auraLockerRewardDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLockerRewardData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLockerRewardData_filter
  ): [AuraLockerRewardData!]!
  auraLockerUserData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerUserData
  auraLockerUserDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLockerUserData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLockerUserData_filter
  ): [AuraLockerUserData!]!
  auraLockerUserLock(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerUserLock
  auraLockerUserLocks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLockerUserLock_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLockerUserLock_filter
  ): [AuraLockerUserLock!]!
  auraLockers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLocker_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLocker_filter
  ): [AuraLocker!]!
  factoryPoolData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FactoryPoolData
  factoryPoolDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FactoryPoolData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FactoryPoolData_filter
  ): [FactoryPoolData!]!
  global(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Global
  globals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Global_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Global_filter
  ): [Global!]!
  masterChef(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MasterChef
  masterChefPoolInfo(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MasterChefPoolInfo
  masterChefPoolInfos(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MasterChefPoolInfo_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MasterChefPoolInfo_filter
  ): [MasterChefPoolInfo!]!
  masterChefUserInfo(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MasterChefUserInfo
  masterChefUserInfos(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MasterChefUserInfo_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MasterChefUserInfo_filter
  ): [MasterChefUserInfo!]!
  masterChefs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MasterChef_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MasterChef_filter
  ): [MasterChef!]!
  merkleDrop(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MerkleDrop
  merkleDropClaim(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MerkleDropClaim
  merkleDropClaims(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MerkleDropClaim_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MerkleDropClaim_filter
  ): [MerkleDropClaim!]!
  merkleDrops(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MerkleDrop_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MerkleDrop_filter
  ): [MerkleDrop!]!
  pool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  poolAccount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolAccount
  poolAccounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolAccount_filter
  ): [PoolAccount!]!
  poolRewardData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolRewardData
  poolRewardDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolRewardData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolRewardData_filter
  ): [PoolRewardData!]!
  pools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Pool_filter
  ): [Pool!]!
  rewardData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardData
  rewardDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RewardData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RewardData_filter
  ): [RewardData!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
}

interface RewardData {
  """
  Last time any user took action
  
  """
  lastUpdateTime: Int!
  """
  Timestamp for current period finish
  
  """
  periodFinish: Int!
  """
  Ever increasing rewardPerToken rate, based on % of total supply
  
  """
  rewardPerTokenStored: BigInt!
  """
  RewardRate for the rest of the period
  
  """
  rewardRate: BigInt!
  token: Token!
}

input RewardData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  lastUpdateTime: Int
  lastUpdateTime_gt: Int
  lastUpdateTime_gte: Int
  lastUpdateTime_in: [Int!]
  lastUpdateTime_lt: Int
  lastUpdateTime_lte: Int
  lastUpdateTime_not: Int
  lastUpdateTime_not_in: [Int!]
  periodFinish: Int
  periodFinish_gt: Int
  periodFinish_gte: Int
  periodFinish_in: [Int!]
  periodFinish_lt: Int
  periodFinish_lte: Int
  periodFinish_not: Int
  periodFinish_not_in: [Int!]
  rewardPerTokenStored: BigInt
  rewardPerTokenStored_gt: BigInt
  rewardPerTokenStored_gte: BigInt
  rewardPerTokenStored_in: [BigInt!]
  rewardPerTokenStored_lt: BigInt
  rewardPerTokenStored_lte: BigInt
  rewardPerTokenStored_not: BigInt
  rewardPerTokenStored_not_in: [BigInt!]
  rewardRate: BigInt
  rewardRate_gt: BigInt
  rewardRate_gte: BigInt
  rewardRate_in: [BigInt!]
  rewardRate_lt: BigInt
  rewardRate_lte: BigInt
  rewardRate_not: BigInt
  rewardRate_not_in: [BigInt!]
  token: String
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
}

enum RewardData_orderBy {
  lastUpdateTime
  periodFinish
  rewardPerTokenStored
  rewardRate
  token
}

type Subscription {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  account(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Account_filter
  ): [Account!]!
  auraLocker(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLocker
  auraLockerAccount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerAccount
  auraLockerAccounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLockerAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLockerAccount_filter
  ): [AuraLockerAccount!]!
  auraLockerRewardData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerRewardData
  auraLockerRewardDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLockerRewardData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLockerRewardData_filter
  ): [AuraLockerRewardData!]!
  auraLockerUserData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerUserData
  auraLockerUserDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLockerUserData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLockerUserData_filter
  ): [AuraLockerUserData!]!
  auraLockerUserLock(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerUserLock
  auraLockerUserLocks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLockerUserLock_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLockerUserLock_filter
  ): [AuraLockerUserLock!]!
  auraLockers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLocker_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLocker_filter
  ): [AuraLocker!]!
  factoryPoolData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FactoryPoolData
  factoryPoolDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FactoryPoolData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FactoryPoolData_filter
  ): [FactoryPoolData!]!
  global(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Global
  globals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Global_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Global_filter
  ): [Global!]!
  masterChef(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MasterChef
  masterChefPoolInfo(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MasterChefPoolInfo
  masterChefPoolInfos(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MasterChefPoolInfo_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MasterChefPoolInfo_filter
  ): [MasterChefPoolInfo!]!
  masterChefUserInfo(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MasterChefUserInfo
  masterChefUserInfos(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MasterChefUserInfo_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MasterChefUserInfo_filter
  ): [MasterChefUserInfo!]!
  masterChefs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MasterChef_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MasterChef_filter
  ): [MasterChef!]!
  merkleDrop(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MerkleDrop
  merkleDropClaim(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MerkleDropClaim
  merkleDropClaims(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MerkleDropClaim_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MerkleDropClaim_filter
  ): [MerkleDropClaim!]!
  merkleDrops(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MerkleDrop_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MerkleDrop_filter
  ): [MerkleDrop!]!
  pool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  poolAccount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolAccount
  poolAccounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolAccount_filter
  ): [PoolAccount!]!
  poolRewardData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolRewardData
  poolRewardDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolRewardData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolRewardData_filter
  ): [PoolRewardData!]!
  pools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Pool_filter
  ): [Pool!]!
  rewardData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardData
  rewardDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RewardData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RewardData_filter
  ): [RewardData!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
}

type Token {
  decimals: Int!
  """
  Address
  
  """
  id: ID!
  name: String!
  symbol: String!
}

input Token_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
}

enum Token_orderBy {
  decimals
  id
  name
  symbol
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}